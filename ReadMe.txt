Задача 4. Написание алгоритма опознания кластеров.
В трехмерном пространстве, ограниченном кубом с центром в точке (0; 0; 0) и длиной стороны 2000 (т.е. максимально возможная координата в этом пространстве +- 1000) сгенерированы K сфер, объем которых равномерно заполнен N = 10 000 точек. K << N и внутри каждой сферы достаточно много точек.

Задача – по имеющимся координатам точек выделить эти K сфер и присвоить каждой точке номер сферы, к которой она относится.

Входные данные: .csv файл, в котором указаны номера точек, три координаты.


Для решения задачи выбран третий вариант, в котором расстояние между сферами достаточно велико. Эта информация позволила слегка загрубить критерий поиска, но при этом сам алгоритм значительно упростился.

Основная идея алгоритма - разбить всю область поиска на сектора, в каждом секторе выделять базовую точку и искать множество точек, удалённое от неё на расстояние 2R. Вторая идея - начать с угла, тем самым вначале мы будем иметь несколько естественных границ.

Описание алгоритма.

1. Исходный куб делится на Меньшие части(в основном кубы с гранью R, но возле границ это будут параллелепипеды с ганью не более R). Нумерация в моём примере выбрана сквозная, по идее похожая на расположение цифровых клавиш на доп.клавиатуре. 
2. Каждой точке расчитывается номер её сектора.
3. Далее цикл по условию наличия точек в базовом векторе. Сортировка базового вектора по номеру сектора.
4. Среди точек с наименьшим номером сектора ищется точка с минимальной x-координатой и берётся в качестве базовой. 
5. Для базовой точки ищутся те, которые отвечают условию попадания в кластер. Всем им значение поля номер кластера присваивается равным текущему.
6. Все точки с найденным значением номера кластера переносятся а результирующий вектор и удаляются из базового.
7. Конец цикла - переход к п.3.
8. После обработки всех точек базовый вектор пуст, все точки с номерами кластеров в результирующем векторе. Его значения сохраняются в файл.


Обоснование метода.

Навеяно методом северо-западного угла и ему похожими.
Начало движения идёт от угла с наименьшими координатами.
Базовая точка выбирается как можно ближе к этому углу и к границам рассматриваемого пространства. Я в качестве критерия взял минимум x-координаты, можно было бы взять длину вектора. Есть варианты, их можно будет потом рассмотреть.
А теперь соображение - найденная нами точка должна лежать внутри некоторого шара, как крайний случай - на его границе. Это значит, что расстояние от этой точки до центра шара не более R - радиуса.  Геометрическое место точек всевозможных центров этих шаров - шар радиусом R с центром в нашей базовой точке. Всевозможное место заполнения таких шаров - это шар радиусом 2R, с центром опять же в нашей точке. Что я и проверяю в условии принадлежности к одному кластеру. Базовые данные о том, что между центрами шаров расстояние 4R позволяет высказать предположение, что мы не захватим другой кластер. Ну а движение по секторам от меньшего номера к большему каждый раз позволяет убрать из рассмотрения точки с меньшими координатами снизу и справа. Начальными оганичителями выступают грани куба.
Думаю, при некоторм изменении можно будет применить этот алгоритм к случаю варианта 4, с разными радиусами, но с большими расстояниями между группами. К первым двум переработать его будет намного сложнее, если вообще можно.

Пряснения по программе.
Поскольку не было оговорено, на каком диалекте С++ надо писать, я старался не использовать специфичные конструкции. Хотя вместо блуждания с векторами иногда всё намного быстрее и проще можно было б сделать LINQ-подобными конструкциями. Выборки, удаления и т.п. Да, стоит отметить, что многое в программе с точки зрения программиста недоделано, по крайней мере алгоритмы надо бы в try-catch, дописать систему выдачи ошибок - кодов и описаний и т.п. Но я посчитал, что основное всё же не оформление, а алгоритм.

Написано и протестировано в Embarcadero  C++Builder XE3.

